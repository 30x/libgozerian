package main

import (
	"net/http"
	"sync"
	"unsafe"
)

/*
#include <stdlib.h>
*/
import "C"

const (
	URNScheme = "urn"
	URNPrefix = URNScheme + ":"
	/* A handler with this URL will always result in a built-in handler for testing. */
	TestHandlerURIName = "weaver-proxy:unit-test"
	TestHandlerURI = URNPrefix + TestHandlerURIName
	/* A handler with this URL is always considered invalid so that we can test that bit. */
	BadHandlerURIName = "weaver-proxy:always-bad"
	BadHandlerURI = URNPrefix + BadHandlerURIName
)

/*
 * The handler object handles requests on behalf of a particular configuration,
 * represented by a handler ID. Instances of this interface are created by the
 * handler implementation by the HandlerFactory. Instances of this interface
 * must be able to handle concurrent requests.
 */
type Handler struct {
  /*
	 * Process an HTTP request.
	 *   Normally, We assume that the request will be passed along
	 * to a target as a proxy. If the headers or URL of the request are changed,
	 * then the modified headers or URL are passed along to the target. If the
	 * "Body" propery of the request is replaced, then the new body is sent
	 * to the target instead of the original request body.
	 *   The ResponseWriter may be used to send a response directly to the client.
	 * It is assumed that when this object is used to generate a response by
	 * calling "Write" or "WriteHeader" that the request is never forwarded
	 * to the proxy, but instead the response set in ResponseWriter is sent
	 * instead.
	 */
	RequestHandler http.HandlerFunc

	/*
	 * Process an HTTP proxy response.
	 *   This method is called after the request was forwarded to a target
	 * server. (If a response was generated in "ServeHTTP" using the ResponseWriter,
	 * then this would never have happened.)
	 *   If the headers or status code of the Response object are changed, then the
	 * new values are returned to the client. If the "Body" property of the Response
	 * object is changed, then the contents of the new Body are sent to the
	 * client instead of what was received by the proxy. Finally, if the
	 * ResponseWriter is used to generate a response, then the response will
	 * replace whatever has been received by the proxy.
	 */
	ResponseHandler func(w http.ResponseWriter, r *http.Request, res *http.Response)
}

/*
 * A global, thread-safe chunk table.
 */

type chunk struct {
	id   int32
	len  uint32
	data unsafe.Pointer
}

var lastChunkID int32 = 1
var chunks = make(map[int32]chunk)
var chunkLock = sync.Mutex{}

/*
 * This is the actual C language interface to weaver. It is basically
 * a small C wrapper to the "manager."
 */

// Functions below are the public C-language API for this code.

/*
 * Create a new handler. This tells the GO implementation to set up some
 * resources for handling requests later. If there was an error creating
 * the handler, then return a string indicating the cause. Otherwise,
 * return NULL. If a string is returned, the caller must free it using "free".
 */
//export GoCreateHandler
func GoCreateHandler(handlerID, configURI *C.char) *C.char {
	err := CreateHandler(C.GoString(handlerID), C.GoString(configURI))
	if err == nil {
		return nil
	}
	return C.CString(err.Error())
}

/*
 * Destroy a handler previously related.
 */
//export GoDestroyHandler
func GoDestroyHandler(handlerID *C.char) {
	DestroyHandler(C.GoString(handlerID))
}

/*
 * Create a new "request" object and return its unique ID. The request
 * goes in a map, so it's important that the caller always call
 * GoFreeRequest or there will be a memory leak.
 */
//export GoCreateRequest
func GoCreateRequest(handlerID *C.char) uint32 {
	return CreateRequest(C.GoString(handlerID))
}

/*
 * Create a new "response" object and return its unique ID.
 * Like the request the response goes in a map and must be freed.
 */
//export GoCreateResponse
func GoCreateResponse(handlerID *C.char) uint32 {
	return CreateResponse(C.GoString(handlerID))
}

/*
 * Clean up any storage used by the request. This method must be called for
 * every ID generated by GoCreateRequest or there will be a memory leak.
 */
//export GoFreeRequest
func GoFreeRequest(id uint32) {
	FreeRequest(id)
}

/*
 * Clean the response like the request.
 */
//export GoFreeResponse
func GoFreeResponse(id uint32) {
	FreeResponse(id)
}

/*
 * Store a chunk of data. The pointer must already have been allocated
 * using "malloc" and the data must be valid for the length of the
 * request. A chunk ID will be returned.
 */
//export GoStoreChunk
func GoStoreChunk(data unsafe.Pointer, len uint32) int32 {
	chunkLock.Lock()
	defer chunkLock.Unlock()

	lastChunkID++
	if lastChunkID < 0 {
		lastChunkID = 1
	}
	c := chunk{
		id:   lastChunkID,
		len:  len,
		data: data,
	}
	chunks[lastChunkID] = c
	return lastChunkID
}

/*
 * Free a chunk of data that was stored using GoStoreChunk. This only frees
 * the data used to track the chunk -- the caller is responsible for
 * actually calling "free".
 */
//export GoReleaseChunk
func GoReleaseChunk(id int32) {
	releaseChunk(id)
}

/*
 * Retrieve the pointer to a chunk of data stored using "GoStoreChunk".
 */
//export GoGetChunk
func GoGetChunk(id int32) unsafe.Pointer {
	return getChunk(id).data
}

/*
 * Retrieve the length of a specific chunk.
 */
//export GoGetChunkLength
func GoGetChunkLength(id int32) uint32 {
	return getChunk(id).len
}

func getChunk(id int32) chunk {
	chunkLock.Lock()
	defer chunkLock.Unlock()
	return chunks[id]
}

func releaseChunk(id int32) {
	chunkLock.Lock()
	defer chunkLock.Unlock()
	delete(chunks, id)
}

/*
 * Start parsing the new request. "rawHeaders" must be a string that
 * represents the HTTP request line and headers, separated by CRLF pairs,
 * exactly as described in the HTTP spec.
 * Once this function has been called, the request is already running.
 * The caller MUST periodically call "GoPollRequest" in order to get updates
 * on the status of the request, and MUST call "GoFreeRequest" after
 * the request is done.
 */
//export GoBeginRequest
func GoBeginRequest(id uint32, rawHeaders *C.char) {
	BeginRequest(id, C.GoString(rawHeaders))
}

/*
 * Poll for updates from the running request. Each update is returned as
 * a null-terminated string. The format of each command string is
 * described in the README.
 * If "block" is non-zero, then block until a command is present. Otherwise,
 * return immediately if there is no command on the queue.
 * The final response from the request will be "DONE." When this is called,
 * then no more commands will be returned. The caller must not poll
 * after "DONE" is returned.
 * The caller is responsible for calling "free" on the returned command string.
 */
//export GoPollRequest
func GoPollRequest(id uint32, block int32) *C.char {
	cmd := PollRequest(id, block != 0)
	if cmd == "" {
		return nil
	}
	return C.CString(cmd)
}

/*
 * Send a chunk of request data to the running goroutine. The second pointer,
 * if non-zero, indicates that this is the last chunk. "data" and "len"
 * must point to valid memory. A copy will be made before this function
 * call returns, so the caller is free to deallocate this memory
 * after calling this function.
 */
//export GoSendRequestBodyChunk
func GoSendRequestBodyChunk(id uint32, l int32, data unsafe.Pointer, len uint32) {
	buf, last := copyPointer(l, data, len)
	SendRequestBodyChunk(id, last, buf)
}

/*
 * Start to handle a response. Like the request path, this starts response
 * handling working in a goroutine, and the caller may poll for changes
 * using GoPollResponse.
 * The response handler may also wish to use the request object, so the
 * request ID (from GoCreateRequest) must also be passed in.
 */
//export GoBeginResponse
func GoBeginResponse(responseID, requestID, status uint32, hdrs *C.char) {
	BeginResponse(responseID, requestID, status, C.GoString(hdrs))
}

/*
 * Like the request path, the response path will also return a set of
 * commands.
 */
//export GoPollResponse
func GoPollResponse(id uint32, block int32) *C.char {
	cmd := PollResponse(id, block != 0)
	if cmd == "" {
		return nil
	}
	return C.CString(cmd)
}

/*
 * Just like request body chunks, but for the response body.
 */
//export GoSendResponseBodyChunk
func GoSendResponseBodyChunk(id uint32, l int32, data unsafe.Pointer, len uint32) {
	buf, last := copyPointer(l, data, len)
	SendResponseBodyChunk(id, last, buf)
}

func copyPointer(l int32, data unsafe.Pointer, len uint32) ([]byte, bool) {
	buf := ptrToSlice(data, len)
	var last bool
	if l != 0 {
		last = true
	}
	return buf, last
}

func ptrToSlice(p unsafe.Pointer, len uint32) []byte {
	var buf []byte
	if p != nil && len > 0 {
		buf = make([]byte, len)
		copy(buf[:], (*[1 << 30]byte)(p)[:])
	}
	return buf
}

func sliceToPtr(buf []byte) (unsafe.Pointer, uint32) {
	l := C.size_t(len(buf))
	ptr := C.malloc(l)
	copy((*[1 << 30]byte)(ptr)[:], buf)
	return ptr, uint32(l)
}
