package main

import (
	"net/http"
	"sync"
	"unsafe"
)

/*
#include <stdlib.h>
*/
import "C"

/*
 * The handler factory is responsible for creating separate handlers for different
 * use cases. It is responsible for creating instances of Handler objects.
 */
type HandlerFactory interface {
	Create(id string) Handler
}

/*
 * The handler object handles requests on behalf of a particular configuration,
 * represented by a handler ID. Instances of this interface are created by the
 * handler implementation by the HandlerFactory. Instances of this interface
 * must be able to handle concurrent requests.
 */
type Handler interface {
	ServeHTTP(w http.ResponseWriter, r *http.Request)
	HandleResponse(r *http.Response)
	Close()
}

/*
 * A global, thread-safe chunk table.
 */

type chunk struct {
	id   int32
	len  uint32
	data unsafe.Pointer
}

var lastChunkID int32 = 1
var chunks = make(map[int32]chunk)
var chunkLock = sync.Mutex{}

/*
 * This is the actual C language interface to weaver. It is basically
 * a small C wrapper to the "manager."
 */

// Functions below are the public C-language API for this code.

/*
 * Create a new handler. This tells the GO implementation to set up some
 * resources for handling requests later.
 */
//export GoCreateHandler
func GoCreateHandler(handlerID *C.char) {
	CreateHandler(C.GoString(handlerID))
}

/*
 * Destroy a handler previously related.
 */
//export GoDestroyHandler
func GoDestroyHandler(handlerID *C.char) {
	DestroyHandler(C.GoString(handlerID))
}

/*
 * Create a new "request" object and return its unique ID. The request
 * goes in a map, so it's important that the caller always call
 * GoFreeRequest or there will be a memory leak.
 */
//export GoCreateRequest
func GoCreateRequest(handlerID *C.char) uint32 {
	return CreateRequest(C.GoString(handlerID))
}

/*
 * Create a new "response" object and return its unique ID.
 * Like the request the response goes in a map and must be freed.
 */
//export GoCreateResponse
func GoCreateResponse(handlerID *C.char) uint32 {
	return CreateResponse(C.GoString(handlerID))
}

/*
 * Clean up any storage used by the request. This method must be called for
 * every ID generated by GoCreateRequest or there will be a memory leak.
 */
//export GoFreeRequest
func GoFreeRequest(id uint32) {
	FreeRequest(id)
}

/*
 * Clean the response like the request.
 */
//export GoFreeResponse
func GoFreeResponse(id uint32) {
	FreeResponse(id)
}

/*
 * Store a chunk of data. The pointer must already have been allocated
 * using "malloc" and the data must be valid for the length of the
 * request. A chunk ID will be returned.
 */
//export GoStoreChunk
func GoStoreChunk(data unsafe.Pointer, len uint32) int32 {
	chunkLock.Lock()
	defer chunkLock.Unlock()

	lastChunkID++
	if lastChunkID < 0 {
		lastChunkID = 1
	}
	c := chunk{
		id:   lastChunkID,
		len:  len,
		data: data,
	}
	chunks[lastChunkID] = c
	return lastChunkID
}

/*
 * Free a chunk of data that was stored using GoStoreChunk. This only frees
 * the data used to track the chunk -- the caller is responsible for
 * actually calling "free".
 */
//export GoReleaseChunk
func GoReleaseChunk(id int32) {
	releaseChunk(id)
}

/*
 * Retrieve the pointer to a chunk of data stored using "GoStoreChunk".
 */
//export GoGetChunk
func GoGetChunk(id int32) unsafe.Pointer {
	return getChunk(id).data
}

/*
 * Retrieve the length of a specific chunk.
 */
//export GoGetChunkLength
func GoGetChunkLength(id int32) uint32 {
	return getChunk(id).len
}

func getChunk(id int32) chunk {
	chunkLock.Lock()
	defer chunkLock.Unlock()
	return chunks[id]
}

func releaseChunk(id int32) {
	chunkLock.Lock()
	defer chunkLock.Unlock()
	delete(chunks, id)
}

/*
 * Start parsing the new request. "rawHeaders" must be a string that
 * represents the HTTP request line and headers, separated by CRLF pairs,
 * exactly as described in the HTTP spec.
 * Once this function has been called, the request is already running.
 * The caller MUST periodically call "GoPollRequest" in order to get updates
 * on the status of the request, and MUST call "GoFreeRequest" after
 * the request is done.
 */
//export GoBeginRequest
func GoBeginRequest(id uint32, rawHeaders *C.char) {
	BeginRequest(id, C.GoString(rawHeaders))
}

/*
 * Poll for updates from the running request. Each update is returned as
 * a null-terminated string. The format of each command string is
 * described in the README.
 * If "block" is non-zero, then block until a command is present. Otherwise,
 * return immediately if there is no command on the queue.
 * The final response from the request will be "DONE." When this is called,
 * then no more commands will be returned. The caller must not poll
 * after "DONE" is returned.
 * The caller is responsible for calling "free" on the returned command string.
 */
//export GoPollRequest
func GoPollRequest(id uint32, block int32) *C.char {
	cmd := PollRequest(id, block != 0)
	if cmd == "" {
		return nil
	}
	return C.CString(cmd)
}

/*
 * Send a chunk of request data to the running goroutine. The second pointer,
 * if non-zero, indicates that this is the last chunk. "data" and "len"
 * must point to valid memory. A copy will be made before this function
 * call returns, so the caller is free to deallocate this memory
 * after calling this function.
 */
//export GoSendRequestBodyChunk
func GoSendRequestBodyChunk(id uint32, l int32, data unsafe.Pointer, len uint32) {
	buf, last := copyPointer(l, data, len)
	SendRequestBodyChunk(id, last, buf)
}

/*
 * Start to handle a response. Like the request path, this starts response
 * handling working in a goroutine, and the caller may poll for changes
 * using GoPollResponse.
 * The response handler may also wish to use the request object, so the
 * request ID (from GoCreateRequest) must also be passed in.
 */
//export GoBeginResponse
func GoBeginResponse(responseID, requestID, status uint32, hdrs *C.char) {
	BeginResponse(responseID, requestID, status, C.GoString(hdrs))
}

/*
 * Like the request path, the response path will also return a set of
 * commands.
 */
//export GoPollResponse
func GoPollResponse(id uint32, block int32) *C.char {
	cmd := PollResponse(id, block != 0)
	if cmd == "" {
		return nil
	}
	return C.CString(cmd)
}

/*
 * Just like request body chunks, but for the response body.
 */
//export GoSendResponseBodyChunk
func GoSendResponseBodyChunk(id uint32, l int32, data unsafe.Pointer, len uint32) {
	buf, last := copyPointer(l, data, len)
	SendResponseBodyChunk(id, last, buf)
}

/*
 * This is a convenience function used to install a test handler that responds
 * to a particular set of API calls.
 */
//export GoInstallTestHandler
func GoInstallTestHandler() {
	SetTestRequestHandler()
}

func copyPointer(l int32, data unsafe.Pointer, len uint32) ([]byte, bool) {
	buf := ptrToSlice(data, len)
	var last bool
	if l != 0 {
		last = true
	}
	return buf, last
}

func ptrToSlice(p unsafe.Pointer, len uint32) []byte {
	var buf []byte
	if p != nil && len > 0 {
		buf = make([]byte, len)
		copy(buf[:], (*[1 << 30]byte)(p)[:])
	}
	return buf
}

func sliceToPtr(buf []byte) (unsafe.Pointer, uint32) {
	l := C.size_t(len(buf))
	ptr := C.malloc(l)
	copy((*[1 << 30]byte)(ptr)[:], buf)
	return ptr, uint32(l)
}
